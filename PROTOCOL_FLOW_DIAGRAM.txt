KEY EXCHANGE PROTOCOL FLOW DIAGRAM
===================================

This diagram shows the complete key exchange protocol flow between User A and User B.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User A    â”‚                                    â”‚   User B    â”‚
â”‚ (Initiator) â”‚                                    â”‚ (Responder) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                                   â”‚
       â”‚  STEP 1: INITIATION                              â”‚
       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
       â”‚                                                   â”‚
       â”‚  1.1 Generate ephemeral ECDH key pair (P-256)     â”‚
       â”‚  1.2 Create initiation message:                  â”‚
       â”‚      {                                            â”‚
       â”‚        ephemeralPublicKey: A_ECDH_pub,            â”‚
       â”‚        fromUserId: A,                            â”‚
       â”‚        nonce,                                     â”‚
       â”‚        timestamp,                                 â”‚
       â”‚        toUserId: B                                â”‚
       â”‚      }                                            â”‚
       â”‚  1.3 Sign message with A's RSA private key       â”‚
       â”‚      (using sorted keys for consistency)          â”‚
       â”‚  1.4 Store ephemeral key pair in IndexedDB       â”‚
       â”‚      (for later use in completion)               â”‚
       â”‚                                                   â”‚
       â”‚  POST /api/key-exchange/initiate                  â”‚
       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                â”‚
       â”‚  {message, signature}                            â”‚
       â”‚                                                   â”‚
       â”‚                                                   â”‚  STEP 2: SERVER RELAY
       â”‚                                                   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚                                                   â”‚
       â”‚                                                   â”‚  2.1 Server validates request
       â”‚                                                   â”‚  2.2 Store key exchange record
       â”‚                                                   â”‚  2.3 Generate exchangeId
       â”‚                                                   â”‚
       â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
       â”‚  {exchangeId, status: "pending"}                  â”‚
       â”‚                                                   â”‚
       â”‚                                                   â”‚  STEP 3: RESPONSE
       â”‚                                                   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚                                                   â”‚
       â”‚                                                   â”‚  3.1 User B polls/retrieves
       â”‚                                                   â”‚      pending exchanges
       â”‚                                                   â”‚
       â”‚  GET /api/key-exchange/pending/:userId            â”‚
       â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
       â”‚  {exchanges: [...]}                              â”‚
       â”‚                                                   â”‚
       â”‚                                                   â”‚  3.2 Verify User A's signature
       â”‚                                                   â”‚  3.3 Generate ephemeral ECDH
       â”‚                                                   â”‚      key pair (P-256)
       â”‚                                                   â”‚  3.4 Import User A's ECDH public key
       â”‚                                                   â”‚  3.5 Derive shared secret:
       â”‚                                                   â”‚      ECDH(B_priv, A_pub)
       â”‚                                                   â”‚  3.6 Generate response nonce
       â”‚                                                   â”‚      (different from initiation nonce)
       â”‚                                                   â”‚  3.7 Derive session key:
       â”‚                                                   â”‚      HKDF(sharedSecret, 
       â”‚                                                   â”‚            "E2EE-SessionKey-{A}-{B}-{responseNonce}")
       â”‚                                                   â”‚  3.8 Create key confirmation:
       â”‚                                                   â”‚      HMAC(derived from sessionKey, 
       â”‚                                                   â”‚            "KeyConfirmation-{responseNonce}")
       â”‚                                                   â”‚  3.9 Create response message:
       â”‚                                                   â”‚      {
       â”‚                                                   â”‚        exchangeId,
       â”‚                                                   â”‚        ephemeralPublicKey: B_ECDH_pub,
       â”‚                                                   â”‚        keyConfirmation,
       â”‚                                                   â”‚        timestamp,
       â”‚                                                   â”‚        nonce: responseNonce
       â”‚                                                   â”‚      }
       â”‚                                                   â”‚  3.10 Sign with B's RSA key
       â”‚                                                   â”‚       (using sorted keys)
       â”‚                                                   â”‚  3.11 Store session key in IndexedDB
       â”‚                                                   â”‚
       â”‚                                                   â”‚  POST /api/key-exchange/respond
       â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
       â”‚  {message, signature}                            â”‚
       â”‚                                                   â”‚
       â”‚  STEP 4: KEY DERIVATION (User A)                  â”‚
       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚
       â”‚                                                   â”‚
       â”‚  4.1 Retrieve ephemeral key pair from IndexedDB  â”‚
       â”‚  4.2 Verify User B's signature                   â”‚
       â”‚      (using original response timestamp)         â”‚
       â”‚  4.3 Import User B's ECDH public key              â”‚
       â”‚  4.4 Derive shared secret:                        â”‚
       â”‚      ECDH(A_priv, B_pub)                          â”‚
       â”‚  4.5 Derive session key:                          â”‚
       â”‚      HKDF(sharedSecret, 
       â”‚            "E2EE-SessionKey-{A}-{B}-{responseNonce}")
       â”‚  4.6 Verify key confirmation:                     â”‚
       â”‚      HMAC(derived from sessionKey, 
       â”‚            "KeyConfirmation-{responseNonce}") 
       â”‚      == keyConfirmation                           â”‚
       â”‚  4.7 Store session key in IndexedDB              â”‚
       â”‚                                                   â”‚
       â”‚  POST /api/key-exchange/confirm                   â”‚
       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                â”‚
       â”‚  {exchangeId, confirmed: true}                    â”‚
       â”‚                                                   â”‚
       â”‚                                                   â”‚  STEP 5: KEY CONFIRMATION
       â”‚                                                   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚                                                   â”‚
       â”‚                                                   â”‚  5.1 Receive confirmation
       â”‚                                                   â”‚  5.2 Both users have same
       â”‚                                                   â”‚      session key
       â”‚                                                   â”‚  5.3 Ready for encrypted
       â”‚                                                   â”‚      communication
       â”‚                                                   â”‚
       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
       â”‚  â”‚  Both users now share the same session key  â”‚ â”‚
       â”‚  â”‚  Session key stored in IndexedDB            â”‚ â”‚
       â”‚  â”‚  Ready for E2EE messaging                   â”‚ â”‚
       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
       â”‚                                                   â”‚


       â”‚  STEP 6: SEND ENCRYPTED MESSAGE (User A)         â”‚
       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
       â”‚                                                   â”‚
       â”‚  6.1 Retrieve session key from IndexedDB        â”‚
       â”‚      (using exchangeId)                         â”‚
       â”‚  6.2 Generate random IV (96 bits = 12 bytes)   â”‚
       â”‚      using window.crypto.getRandomValues()      â”‚
       â”‚  6.3 Encrypt plaintext with AES-256-GCM:        â”‚
       â”‚      - Algorithm: AES-GCM                        â”‚
       â”‚      - Key: Session key (256 bits)              â”‚
       â”‚      - IV: Random 96-bit IV                     â”‚
       â”‚      - Tag Length: 128 bits                      â”‚
       â”‚  6.4 Extract ciphertext and authentication tag â”‚
       â”‚  6.5 Encode to base64:                          â”‚
       â”‚      {ciphertext, iv, tag}                     â”‚
       â”‚                                                   â”‚
       â”‚  POST /api/messages/send                        â”‚
       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                â”‚
       â”‚  {                                               â”‚
       â”‚    fromUserId: A,                               â”‚
       â”‚    toUserId: B,                                 â”‚
       â”‚    exchangeId,                                  â”‚
       â”‚    ciphertext: base64,                          â”‚
       â”‚    iv: base64,                                  â”‚
       â”‚    tag: base64,                                 â”‚
       â”‚    timestamp,                                   â”‚
       â”‚    messageType: "text"                          â”‚
       â”‚  }                                               â”‚
       â”‚                                                   â”‚
       â”‚                                                   â”‚  STEP 7: SERVER STORAGE
       â”‚                                                   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚                                                   â”‚
       â”‚                                                   â”‚  7.1 Server validates request
       â”‚                                                   â”‚  7.2 Store encrypted message:
       â”‚                                                   â”‚      - ciphertext (base64)
       â”‚                                                   â”‚      - iv (base64)
       â”‚                                                   â”‚      - tag (base64)
       â”‚                                                   â”‚      - metadata (fromUserId, toUserId,
       â”‚                                                   â”‚        exchangeId, timestamp, status)
       â”‚                                                   â”‚  7.3 Server CANNOT decrypt
       â”‚                                                   â”‚      (E2EE - server has no keys)
       â”‚                                                   â”‚
       â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
       â”‚  {success: true, messageId}                      â”‚
       â”‚                                                   â”‚
       â”‚                                                   â”‚  STEP 8: RECEIVE & DECRYPT (User B)
       â”‚                                                   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚                                                   â”‚
       â”‚                                                   â”‚  8.1 User B polls/requests messages
       â”‚                                                   â”‚
       â”‚  GET /api/messages/:userId1/:userId2            â”‚
       â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
       â”‚  {messages: [{ciphertext, iv, tag, ...}]}       â”‚
       â”‚                                                   â”‚
       â”‚                                                   â”‚  8.2 Retrieve session key from IndexedDB
       â”‚                                                   â”‚      (using exchangeId)
       â”‚                                                   â”‚  8.3 Decode base64: ciphertext, iv, tag
       â”‚                                                   â”‚  8.4 Combine ciphertext + tag
       â”‚                                                   â”‚      (AES-GCM format)
       â”‚                                                   â”‚  8.5 Decrypt using AES-256-GCM:
       â”‚                                                   â”‚      - Algorithm: AES-GCM
       â”‚                                                   â”‚      - Key: Session key
       â”‚                                                   â”‚      - IV: From message
       â”‚                                                   â”‚      - Tag: From message
       â”‚                                                   â”‚  8.6 Decode plaintext bytes to string
       â”‚                                                   â”‚  8.7 Display decrypted message in UI
       â”‚                                                   â”‚
       â”‚                                                   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                                                   â”‚  â”‚  Message successfully        â”‚
       â”‚                                                   â”‚  â”‚  decrypted and displayed     â”‚
       â”‚                                                   â”‚  â”‚  ğŸ”’ Encrypted with           â”‚
       â”‚                                                   â”‚  â”‚     AES-256-GCM             â”‚
       â”‚                                                   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                                   â”‚


SECURITY FEATURES IN EACH STEP:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Step 1 (Initiation):
  âœ“ Ephemeral keys (forward secrecy)
  âœ“ Digital signature (authenticity)
  âœ“ Nonce (replay protection)
  âœ“ Timestamp (replay protection)

Step 2 (Server Relay):
  âœ“ Server only stores metadata
  âœ“ No access to private keys
  âœ“ No access to session keys

Step 3 (Response):
  âœ“ Signature verification
  âœ“ Ephemeral keys
  âœ“ Key confirmation HMAC
  âœ“ Nonce

Step 4 (Key Derivation):
  âœ“ Signature verification
  âœ“ Key confirmation verification
  âœ“ Secure key derivation (HKDF)

Step 5 (Confirmation):
  âœ“ Both parties confirmed
  âœ“ Session key established

Step 6 (Send Message):
  âœ“ Random IV per message (prevents pattern analysis)
  âœ“ AES-256-GCM encryption (authenticated encryption)
  âœ“ Server cannot decrypt (true E2EE)
  âœ“ Authentication tag (integrity verification)

Step 7 (Server Storage):
  âœ“ Server only stores encrypted data
  âœ“ No plaintext access
  âœ“ Metadata only (for routing/display)

Step 8 (Receive & Decrypt):
  âœ“ Client-side decryption only
  âœ“ Authentication tag verification
  âœ“ Integrity check (tamper detection)


MESSAGE FORMATS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Initiation Message:
{
  fromUserId: string,
  toUserId: string,
  ephemeralPublicKey: string (base64 SPKI),
  timestamp: number,
  nonce: string (base64),
  signature: string (base64 RSA-PSS)
}

Response Message:
{
  exchangeId: string,
  ephemeralPublicKey: string (base64 SPKI),
  keyConfirmation: string (base64 HMAC),
  timestamp: number,
  nonce: string (base64),
  signature: string (base64 RSA-PSS)
}

Confirmation Message:
{
  exchangeId: string,
  confirmed: boolean
}

Encrypted Message (Send):
{
  fromUserId: string,
  toUserId: string,
  exchangeId: string,
  ciphertext: string (base64),
  iv: string (base64, 96 bits),
  tag: string (base64, 128 bits),
  timestamp: number,
  messageType: string ("text" | "file")
}

Message Response (Get):
{
  success: boolean,
  messages: [
    {
      _id: string,
      fromUserId: ObjectId,
      toUserId: ObjectId,
      ciphertext: string (base64),
      iv: string (base64),
      tag: string (base64),
      timestamp: Date,
      messageType: string,
      status: string,
      createdAt: Date
    }
  ]
}


KEY DERIVATION DETAILS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

HKDF Parameters:
  - Input: ECDH shared secret (256 bits)
  - Hash: SHA-256
  - Salt: None (can be improved)
  - Info: "E2EE-SessionKey-{fromUserId}-{toUserId}-{nonce}"
  - Output: 256-bit AES-GCM key

Key Confirmation:
  - Algorithm: HMAC-SHA-256
  - HMAC Key: Derived from session key (AES key material)
  - Input Message: "KeyConfirmation-{responseNonce}"
  - Output: 256-bit HMAC (base64 encoded)
  - Note: Uses responseNonce (not initiation nonce)

Message Encryption (AES-256-GCM):
  - Algorithm: AES-GCM (Galois/Counter Mode)
  - Key Size: 256 bits (from HKDF-derived session key)
  - IV Size: 96 bits (12 bytes) - random per message
  - Tag Size: 128 bits (16 bytes) - authentication tag
  - IV Generation: window.crypto.getRandomValues()
  - Encryption: Client-side only (Web Crypto API)
  - Decryption: Client-side only (Web Crypto API)
  - Server Role: Storage only (cannot decrypt)


PROTOCOL SECURITY ANALYSIS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MITM Attack Prevention:
  âœ“ Digital signatures ensure authenticity
  âœ“ Public keys retrieved from trusted server
  âœ“ Signature verification at each step

Replay Attack Prevention:
  âœ“ Nonces in each message
  âœ“ Timestamps
  âœ“ Exchange IDs (one-time use)
  âœ“ Expiration (1 hour)

Forward Secrecy:
  âœ“ Ephemeral ECDH keys (temporary)
  âœ“ Keys discarded after session

Key Confirmation:
  âœ“ HMAC verification ensures both parties
    derived the same key
  âœ“ Prevents key mismatch attacks

Message Encryption Security:
  âœ“ Random IV per message (prevents IV reuse attacks)
  âœ“ AES-256-GCM (authenticated encryption)
  âœ“ Authentication tag (detects tampering)
  âœ“ Server cannot decrypt (true end-to-end encryption)
  âœ“ Forward secrecy (ephemeral keys from key exchange)
  âœ“ No plaintext on server (only ciphertext, IV, tag)

